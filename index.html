<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1 ">
<title></title>

<link rel="stylesheet" href=""> </head>
  <body>
    <canvas id="myCanvas" width="120" height="300" style="border: 1px solid black;"></canvas>
  </body>

  <script>
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');


/**
 * Draws multiple standard deviational ellipses (dispersion ovals) on a canvas.
 *
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 * @param {Array<Object>} datasets - An array of dataset objects, where each dataset has 'color' and 'data' properties.
 * @param {number} [scaleX=1] - A scaling factor for the x-coordinates.
 * @param {number} [scaleY=1] - A scaling factor for the y-coordinates.
 */
function drawMultipleDispersionOvals(ctx, datasets, scaleX = 1, scaleY = 1) {
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;

  datasets.forEach((dataset, i) => {
    const data = dataset.data;
    const color = dataset.color;
    
    if (data.length < 2) {
      console.error("Not enough data points in a dataset to draw a dispersion oval.");
      return;
    }

    // 1. Calculate the mean center
    const n = data.length;
    const sumX = data.reduce((acc, point) => acc + point.x, 0);
    const sumY = data.reduce((acc, point) => acc + point.y, 0);
    const meanX = sumX / n;
    const meanY = sumY / n;

    // 2. Calculate the orientation (theta)
    const tildeX = data.map((point) => point.x - meanX);
    const tildeY = data.map((point) => point.y - meanY);

    const sumTildeXSquared = tildeX.reduce((acc, val) => acc + val * val, 0);
    const sumTildeYSquared = tildeY.reduce((acc, val) => acc + val * val, 0);
    const sumTildeXY = tildeX.reduce((acc, val, i) => acc + val * tildeY[i], 0);

    const theta =
      Math.atan(
        (sumTildeXSquared - sumTildeYSquared + Math.sqrt(Math.pow(sumTildeXSquared - sumTildeYSquared, 2) + 4 * Math.pow(sumTildeXY, 2))) / (2 * sumTildeXY)
      );

    // 3. Calculate the semi-axes
    const sigmaX = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.cos(theta) - tildeY[i] * Math.sin(theta), 2),
        0
      ) / n
    );

    const sigmaY = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.sin(theta) - tildeY[i] * Math.cos(theta), 2),
        0
      ) / n
    );

    // 4. Draw the ellipse using standard canvas coordinates
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;

    // Convert to canvas coordinates (origin at top-left, Y increases downward)
    const canvasX = canvasWidth / 2 + meanX * scaleX;
    const canvasY = canvasHeight - meanY * scaleY; // Flip Y to match our data coordinate system

    // Calculate radii with minimum size
    const minRadius = 1;
    const rx = Math.max(sigmaX * scaleX, minRadius);
    const ry = Math.max(sigmaY * scaleY, minRadius);

    // Draw ellipse using the ellipse method directly at the correct angle
    ctx.beginPath();
    ctx.ellipse(canvasX, canvasY, rx, ry, theta, 0, 2 * Math.PI);
    ctx.stroke();
    
    ctx.restore();
  });
}

/**
 * Draws a grid on the canvas with curved distance lines every 50 yards and a vertical center line
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 */
function drawGrid(ctx) {
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  
  ctx.save();
  
  // Set grid line style
  ctx.strokeStyle = '#cccccc';
  ctx.lineWidth = 1;
  ctx.font = '10px Arial';
  ctx.fillStyle = '#666666';
  
  // Draw curved distance lines every 50 yards from bottom center
  // Each curved line is an arc where every point is the same distance from the tee (bottom center)
  const teeX = canvasWidth / 2;
  const teeY = canvasHeight;
  
  for (let distance = 50; distance <= 300; distance += 50) {
    const radius = distance; // Distance from tee
    
    ctx.beginPath();
    // Calculate the angle range that intersects with the canvas
    const halfWidth = canvasWidth / 2;
    const maxAngle = Math.asin(Math.min(1, halfWidth / radius));
    
    // Draw the arc representing all points at this distance from the tee
    ctx.arc(teeX, teeY, radius, Math.PI - maxAngle, Math.PI + maxAngle);
    ctx.stroke();
    
    // Add yard labels on the left side at consistent positions
    // Position label at the leftmost visible point of the arc
    const labelX = 5; // Fixed left margin for consistency
    const labelY = teeY - radius + 3; // Height based on distance from tee
    
    // Only show label if it's within canvas bounds
    if (labelY > 10 && labelY < canvasHeight - 5) {
      ctx.fillText(distance + ' yds', labelX, labelY);
    }
  }
  
  // Draw vertical center line (represents the target line)
  ctx.beginPath();
  ctx.strokeStyle = '#999999';
  ctx.lineWidth = 2;
  ctx.moveTo(canvasWidth / 2, 0);
  ctx.lineTo(canvasWidth / 2, canvasHeight);
  ctx.stroke();
  
  ctx.restore();
}

/**
 * Draws trajectory paths from the tee to each shot landing point
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 * @param {Array<Object>} datasets - An array of dataset objects with shot data
 * @param {number} [scaleX=1] - A scaling factor for the x-coordinates.
 * @param {number} [scaleY=1] - A scaling factor for the y-coordinates.
 */
function drawTrajectoryPaths(ctx, datasets, scaleX = 1, scaleY = 1) {
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  const teeX = canvasWidth / 2;
  const teeY = canvasHeight;

  datasets.forEach((dataset) => {
    const data = dataset.data;
    const color = dataset.color;
    
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 2]); // Dashed line for trajectory paths
    
    // Draw a curved path from tee to each shot landing point
    data.forEach((point) => {
      // Convert data coordinates to canvas coordinates
      const landingX = canvasWidth / 2 + point.x * scaleX;
      const landingY = canvasHeight - point.y * scaleY;
      
      // Create a parabolic trajectory path
      ctx.beginPath();
      ctx.moveTo(teeX, teeY);
      
      // Calculate control point for quadratic curve (creates arc effect)
      // Control point is above the midpoint to simulate ball flight arc
      const midX = (teeX + landingX) / 2;
      const midY = (teeY + landingY) / 2;
      const controlX = midX;
      const controlY = midY - point.y * 0.3; // Arc height proportional to distance
      
      // Draw quadratic curve from tee to landing point
      ctx.quadraticCurveTo(controlX, controlY, landingX, landingY);
      ctx.stroke();
    });
    
    ctx.restore();
  });
}

const allData = [
  // First dataset for a red ellipse (right side, mid-field)
  {
    color: 'red',
    data: [{ x: 30, y: 120 }, { x: 35, y: 130 }, { x: 40, y: 125 }]
  },
  // Second dataset for a blue ellipse (left side, lower field)
  {
    color: 'blue',
    data: [{ x: -25, y: 80 }, { x: -30, y: 85 }, { x: -20, y: 75 }]
  },
  // Third dataset for a green ellipse (right side, upper field)
  {
    color: 'green',
    data: [{ x: 45, y: 220 }, { x: 50, y: 230 }, { x: 40, y: 210 }, { x: 35, y: 225 }]
  },
  // Fourth dataset for an orange ellipse (left side, mid-field)
  {
    color: 'orange',
    data: [{ x: -40, y: 150 }, { x: -35, y: 160 }, { x: -45, y: 155 }, { x: -50, y: 145 }]
  },
  // Fifth dataset for a purple ellipse (center, upper field)
  {
    color: 'purple',
    data: [{ x: 10, y: 250 }, { x: 15, y: 260 }, { x: 5, y: 255 }, { x: 0, y: 245 }, { x: 20, y: 265 }]
  },
  // Sixth dataset for a black circle near the goal line (center)
  {
    color: 'black',
    data: [
      { x: 12, y: 25 },   // right
      { x: -12, y: 25 },  // left  
      { x: 0, y: 35 },    // up
      { x: 0, y: 15 },    // down
      { x: 8.5, y: 33.5 },   // up-right diagonal
      { x: -8.5, y: 16.5 },  // down-left diagonal
      { x: 8.5, y: 16.5 },   // down-right diagonal
      { x: -8.5, y: 33.5 }   // up-left diagonal
    ]
  }
];



if (ctx) {
  // Draw the grid first (background)
  drawGrid(ctx);
  
  // Draw trajectory paths second (behind the dispersion ovals)
  const scaleX = 1; 
  const scaleY = 1; 
  drawTrajectoryPaths(ctx, allData, scaleX, scaleY);
  
  // Then draw the dispersion ovals on top
  drawMultipleDispersionOvals(ctx, allData, scaleX, scaleY);
}

  
  
  </script>
  
</html>
