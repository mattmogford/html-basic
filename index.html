<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1 ">
<title></title>

<link rel="stylesheet" href=""> </head>
  <body>
    <canvas id="myCanvas" width="800" height="600" style="border: 1px solid black;"></canvas>
  </body>

  <script>
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');


/**
 * Draws multiple standard deviational ellipses (dispersion ovals) on a canvas.
 *
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 * @param {Array<Object>} datasets - An array of dataset objects, where each dataset has 'color' and 'data' properties.
 * @param {number} [scaleX=1] - A scaling factor for the x-coordinates.
 * @param {number} [scaleY=1] - A scaling factor for the y-coordinates.
 */
function drawMultipleDispersionOvals(ctx, datasets, scaleX = 1, scaleY = 1) {
  // Translate the canvas to make the center (0,0) only once
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  ctx.translate(canvasWidth / 2, canvasHeight / 2);

  datasets.forEach((dataset, i) => {
    const data = dataset.data;
    const color = dataset.color;
    
    if (data.length < 2) {
      console.error("Not enough data points in a dataset to draw a dispersion oval.");
      return;
    }

    // 1. Calculate the mean center
    const n = data.length;
    const sumX = data.reduce((acc, point) => acc + point.x, 0);
    const sumY = data.reduce((acc, point) => acc + point.y, 0);
    const meanX = sumX / n;
    const meanY = sumY / n;

    // 2. Calculate the orientation (theta)
    const tildeX = data.map((point) => point.x - meanX);
    const tildeY = data.map((point) => point.y - meanY);

    const sumTildeXSquared = tildeX.reduce((acc, val) => acc + val * val, 0);
    const sumTildeYSquared = tildeY.reduce((acc, val) => acc + val * val, 0);
    const sumTildeXY = tildeX.reduce((acc, val, i) => acc + val * tildeY[i], 0);

    const theta =
      Math.atan(
        (sumTildeXSquared - sumTildeYSquared + Math.sqrt(Math.pow(sumTildeXSquared - sumTildeYSquared, 2) + 4 * Math.pow(sumTildeXY, 2))) / (2 * sumTildeXY)
      );

    // 3. Calculate the semi-axes
    const sigmaX = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.cos(theta) - tildeY[i] * Math.sin(theta), 2),
        0
      ) / n
    );

    const sigmaY = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.sin(theta) - tildeY[i] * Math.cos(theta), 2),
        0
      ) / n
    );

    // 4. Draw the ellipse on the canvas
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = color; // Use the color from the dataset
    ctx.lineWidth = 2;

    // Translate to the center of the ellipse, relative to the canvas's new (0,0)
    ctx.translate(meanX * scaleX, meanY * scaleY);
    // Rotate the canvas to the ellipse's angle
    ctx.rotate(theta);
    // Scale the context to draw the ellipse as a circle
    const minRadius = 1;
    const rx = Math.max(sigmaX * scaleX, minRadius);
    const ry = Math.max(sigmaY * scaleY, minRadius);
    ctx.scale(rx, ry);

    // Draw a circle which will become the ellipse
    ctx.arc(0, 0, 1, 0, 2 * Math.PI);

    ctx.stroke();
    ctx.restore();
  });
}



const allData = [
  // First dataset for a red ellipse
  {
    color: 'red',
    data: [{ x: 100, y: 150 }, { x: 120, y: 170 }, { x: 150, y: 180 }]
  },
  // Second dataset for a blue ellipse
  {
    color: 'blue',
    data: [{ x: -50, y: -70 }, { x: -60, y: -80 }, { x: -40, y: -60 }]
  },
  // Third dataset for a green ellipse
  {
    color: 'green',
    data: [{ x: 200, y: -100 }, { x: 220, y: -90 }, { x: 210, y: -120 }, { x: 190, y: -110 }]
  },
  // Fourth dataset for an orange ellipse
  {
    color: 'orange',
    data: [{ x: -150, y: 100 }, { x: -140, y: 120 }, { x: -160, y: 110 }, { x: -170, y: 90 }]
  },
  // Fifth dataset for a purple ellipse
  {
    color: 'purple',
    data: [{ x: 50, y: -200 }, { x: 70, y: -180 }, { x: 60, y: -210 }, { x: 40, y: -190 }, { x: 80, y: -170 }]
  }
];



if (ctx) {
  // Assuming a simple scaling
  const scaleX = 1; 
  const scaleY = 1; 
  drawMultipleDispersionOvals(ctx, allData, scaleX, scaleY);
}

  
  
  </script>
  
</html>
