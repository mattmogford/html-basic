<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="vi ewport" content="width=device-width, initial-scale=1 ">
<title></title>

<link rel="stylesheet" href=""> </head>
  <body>
    <canvas id="myCanvas" width="800" height="600" style="border: 1px solid black;"></canvas>
  </body>

  <script>
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');


/**
 * Draws multiple standard deviational ellipses (dispersion ovals) on a canvas.
 *
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 * @param {Array<Array<Object>>} datasets - An array of datasets, where each dataset is an array of objects with 'x' and 'y' properties.
 * @param {number} [scaleX=1] - A scaling factor for the x-coordinates.
 * @param {number} [scaleY=1] - A scaling factor for the y-coordinates.
 */
function drawMultipleDispersionOvals(ctx, datasets, scaleX = 1, scaleY = 1) {
  // Translate the canvas to make the center (0,0)
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  ctx.translate(canvasWidth / 2, canvasHeight / 2);

  datasets.forEach((data) => {
    if (data.length < 2) {
      console.error("Not enough data points in a dataset to draw a dispersion oval.");
      return;
    }

    // 1. Calculate the mean center
    const n = data.length;
    const sumX = data.reduce((acc, point) => acc + point.x, 0);
    const sumY = data.reduce((acc, point) => acc + point.y, 0);
    const meanX = sumX / n;
    const meanY = sumY / n;

    // 2. Calculate the orientation (theta)
    const tildeX = data.map((point) => point.x - meanX);
    const tildeY = data.map((point) => point.y - meanY);

    const sumTildeXSquared = tildeX.reduce((acc, val) => acc + val * val, 0);
    const sumTildeYSquared = tildeY.reduce((acc, val) => acc + val * val, 0);
    const sumTildeXY = tildeX.reduce((acc, val, i) => acc + val * tildeY[i], 0);

    const theta =
      Math.atan(
        (sumTildeXSquared - sumTildeYSquared + Math.sqrt(Math.pow(sumTildeXSquared - sumTildeYSquared, 2) + 4 * Math.pow(sumTildeXY, 2))) / (2 * sumTildeXY)
      );

    // 3. Calculate the semi-axes
    const sigmaX = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.cos(theta) - tildeY[i] * Math.sin(theta), 2),
        0
      ) / n
    );

    const sigmaY = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.sin(theta) - tildeY[i] * Math.cos(theta), 2),
        0
      ) / n
    );

    // 4. Draw the ellipse on the canvas
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;

    // Apply the transformation matrix
    ctx.setTransform(
      sigmaX * scaleX * Math.cos(theta),  // a
      sigmaX * scaleX * Math.sin(theta),  // b
      -sigmaY * scaleY * Math.sin(theta), // c
      sigmaY * scaleY * Math.cos(theta),  // d
      meanX * scaleX + canvasWidth / 2,   // e (translation x)
      meanY * scaleY + canvasHeight / 2   // f (translation y)
    );

    // Draw a circle at the origin of the transformed context
    ctx.arc(0, 0, 1, 0, 2 * Math.PI);

    ctx.stroke();
    ctx.restore();
  });
}


const allData = [
  // First dataset for a red ellipse
  [{ x: 100, y: 150 }, { x: 120, y: 170 }, { x: 150, y: 180 }],
  // Second dataset for a blue ellipse
  [{ x: -50, y: -70 }, { x: -60, y: -80 }, { x: -40, y: -60 }]
];



if (ctx) {
  // Assuming a simple scaling
  const scaleX = 1; 
  const scaleY = 1; 
  drawMultipleDispersionOvals(ctx, allData, scaleX, scaleY);
}

  
  
  </script>
  
</html>
