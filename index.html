<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1 ">
<title></title>

<link rel="stylesheet" href=""> </head>
  <body>
    <canvas id="myCanvas" width="120" height="300" style="border: 1px solid black;"></canvas>
  </body>

  <script>
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');


/**
 * Draws multiple standard deviational ellipses (dispersion ovals) on a canvas.
 *
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 * @param {Array<Object>} datasets - An array of dataset objects, where each dataset has 'color' and 'data' properties.
 * @param {number} [scaleX=1] - A scaling factor for the x-coordinates.
 * @param {number} [scaleY=1] - A scaling factor for the y-coordinates.
 */
function drawMultipleDispersionOvals(ctx, datasets, scaleX = 1, scaleY = 1) {
  // Translate the canvas to make (0,0) at bottom middle
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  ctx.translate(canvasWidth / 2, canvasHeight);

  datasets.forEach((dataset, i) => {
    const data = dataset.data;
    const color = dataset.color;
    
    if (data.length < 2) {
      console.error("Not enough data points in a dataset to draw a dispersion oval.");
      return;
    }

    // 1. Calculate the mean center
    const n = data.length;
    const sumX = data.reduce((acc, point) => acc + point.x, 0);
    const sumY = data.reduce((acc, point) => acc + point.y, 0);
    const meanX = sumX / n;
    const meanY = sumY / n;

    // 2. Calculate the orientation (theta)
    const tildeX = data.map((point) => point.x - meanX);
    const tildeY = data.map((point) => point.y - meanY);

    const sumTildeXSquared = tildeX.reduce((acc, val) => acc + val * val, 0);
    const sumTildeYSquared = tildeY.reduce((acc, val) => acc + val * val, 0);
    const sumTildeXY = tildeX.reduce((acc, val, i) => acc + val * tildeY[i], 0);

    const theta =
      Math.atan(
        (sumTildeXSquared - sumTildeYSquared + Math.sqrt(Math.pow(sumTildeXSquared - sumTildeYSquared, 2) + 4 * Math.pow(sumTildeXY, 2))) / (2 * sumTildeXY)
      );

    // 3. Calculate the semi-axes
    const sigmaX = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.cos(theta) - tildeY[i] * Math.sin(theta), 2),
        0
      ) / n
    );

    const sigmaY = Math.sqrt(
      tildeX.reduce(
        (acc, val, i) => acc + Math.pow(val * Math.sin(theta) - tildeY[i] * Math.cos(theta), 2),
        0
      ) / n
    );

    // 4. Draw the ellipse on the canvas
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = color; // Use the color from the dataset
    ctx.lineWidth = 2;

    // Translate to the center of the ellipse, relative to the canvas's new (0,0)
    // Note: Y is flipped since we want positive Y to go up from bottom
    ctx.translate(meanX * scaleX, -meanY * scaleY);
    // Rotate the canvas to the ellipse's angle
    ctx.rotate(theta);
    // Scale the context to draw the ellipse as a circle
    const minRadius = 1;
    const rx = Math.max(sigmaX * scaleX, minRadius);
    const ry = Math.max(sigmaY * scaleY, minRadius);
    ctx.scale(rx, ry);

    // Draw a circle which will become the ellipse
    ctx.arc(0, 0, 1, 0, 2 * Math.PI);

    ctx.stroke();
    ctx.restore();
  });
}

/**
 * Draws a grid on the canvas with horizontal lines every 50 yards and a vertical center line
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 */
function drawGrid(ctx) {
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  
  ctx.save();
  
  // Set grid line style
  ctx.strokeStyle = '#cccccc';
  ctx.lineWidth = 1;
  ctx.font = '10px Arial';
  ctx.fillStyle = '#666666';
  
  // Transform to our coordinate system (0,0 at bottom middle)
  ctx.translate(canvasWidth / 2, canvasHeight);
  
  // Draw horizontal lines every 50 yards (pixels) from bottom
  for (let y = 0; y <= canvasHeight; y += 50) {
    ctx.beginPath();
    ctx.moveTo(-canvasWidth / 2, -y);
    ctx.lineTo(canvasWidth / 2, -y);
    ctx.stroke();
    
    // Add yard labels on the left side
    ctx.save();
    ctx.scale(1, -1); // Flip text so it's readable
    ctx.fillText(y + ' yds', -canvasWidth / 2 + 2, y - 2);
    ctx.restore();
  }
  
  // Draw vertical center line
  ctx.beginPath();
  ctx.strokeStyle = '#999999';
  ctx.lineWidth = 2;
  ctx.moveTo(0, 0);
  ctx.lineTo(0, -canvasHeight);
  ctx.stroke();
  
  ctx.restore();
}

const allData = [
  // First dataset for a red ellipse (right side, mid-field)
  {
    color: 'red',
    data: [{ x: 30, y: 120 }, { x: 35, y: 130 }, { x: 40, y: 125 }]
  },
  // Second dataset for a blue ellipse (left side, lower field)
  {
    color: 'blue',
    data: [{ x: -25, y: 80 }, { x: -30, y: 85 }, { x: -20, y: 75 }]
  },
  // Third dataset for a green ellipse (right side, upper field)
  {
    color: 'green',
    data: [{ x: 45, y: 220 }, { x: 50, y: 230 }, { x: 40, y: 210 }, { x: 35, y: 225 }]
  },
  // Fourth dataset for an orange ellipse (left side, mid-field)
  {
    color: 'orange',
    data: [{ x: -40, y: 150 }, { x: -35, y: 160 }, { x: -45, y: 155 }, { x: -50, y: 145 }]
  },
  // Fifth dataset for a purple ellipse (center, upper field)
  {
    color: 'purple',
    data: [{ x: 10, y: 250 }, { x: 15, y: 260 }, { x: 5, y: 255 }, { x: 0, y: 245 }, { x: 20, y: 265 }]
  },
  // Sixth dataset for a black circle near the goal line (center)
  {
    color: 'black',
    data: [
      { x: 12, y: 25 },   // right
      { x: -12, y: 25 },  // left  
      { x: 0, y: 35 },    // up
      { x: 0, y: 15 },    // down
      { x: 8.5, y: 33.5 },   // up-right diagonal
      { x: -8.5, y: 16.5 },  // down-left diagonal
      { x: 8.5, y: 16.5 },   // down-right diagonal
      { x: -8.5, y: 33.5 }   // up-left diagonal
    ]
  }
];



if (ctx) {
  // Draw the grid first (background)
  drawGrid(ctx);
  
  // Then draw the dispersion ovals on top
  const scaleX = 1; 
  const scaleY = 1; 
  drawMultipleDispersionOvals(ctx, allData, scaleX, scaleY);
}

  
  
  </script>
  
</html>
